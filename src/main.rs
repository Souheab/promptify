use std::{fs, path::PathBuf};
use anyhow::{Context, Result};
use bytesize::ByteSize;
use clap::Parser;  // Added this import
use content_inspector::ContentType;
use glob::Pattern;
use ignore::WalkBuilder;
use pathdiff::diff_paths;

mod cli;
mod file_utils;
mod language;
mod tree;

const DEFAULT_PREAMBLE: &str = "\
# Project Context
This content was generated using `promptify`, a tool that creates structured project overviews \
for Large Language Models. Below you'll find a directory tree and the contents of relevant files \
from this project.
## How to Read This Document
- The 'Directory Structure' section shows the project's file organization
- The 'File Contents' section contains the actual code and content of each file
- Each file is marked with its path and language-appropriate syntax highlighting
";

const DEFAULT_POSTAMBLE: &str = "\
---
[Instructions for AI that is reading this: Please respond by:
1. Acknowledging that you've received this project overview generated by promptify
2. Briefly describing what you understand about this codebase's / folder's purpose
3. Asking the user what specific assistance they need with the code]
";

fn main() -> Result<()> {
    let cli = cli::Cli::parse();

    // Set up file size limit
    let size_limit = cli.max_file_size
        .as_deref()
        .map(file_utils::parse_size)
        .transpose()?;

    // Compile glob patterns
    let include_patterns: Vec<_> = cli.include
        .iter()
        .map(|p| Pattern::new(p))
        .collect::<Result<_, _>>()
        .context("Invalid include pattern")?;
    
    let exclude_patterns: Vec<_> = cli.exclude
        .iter()
        .map(|p| Pattern::new(p))
        .collect::<Result<_, _>>()
        .context("Invalid exclude pattern")?;

    // Load preamble and postamble
    let preamble = if let Some(text) = cli.preamble {
        text
    } else if let Some(path) = cli.preamble_file {
        file_utils::load_file_content(&path)?
    } else {
        DEFAULT_PREAMBLE.to_string()
    };

    let postamble = if let Some(text) = cli.postamble {
        text
    } else if let Some(path) = cli.postamble_file {
        file_utils::load_file_content(&path)?
    } else {
        DEFAULT_POSTAMBLE.to_string()
    };

    // Collect files
    let mut files = Vec::new();
    let walker = WalkBuilder::new(&cli.root_path)
        .git_ignore(!cli.no_gitignore)
        .build();

    for entry in walker {
        let entry = entry.context("Failed to read directory entry")?;
        let path = entry.path();
        if !path.is_file() {
            continue;
        }

        let relative_path = diff_paths(path, &cli.root_path)
            .context("Failed to calculate relative path")?;
        let relative_path_str = relative_path.to_string_lossy();

        // Check exclude patterns first (they take precedence)
        if exclude_patterns.iter().any(|p| p.matches(&relative_path_str)) {
            eprintln!("Info: Excluding file: {}", relative_path_str);
            continue;
        }

        // Check if file matches include patterns
        let is_included = include_patterns.is_empty() || 
            include_patterns.iter().any(|p| p.matches(&relative_path_str));
        if !is_included {
            continue;
        }

        // Check file size
        if let Some(limit) = size_limit {
            let size = entry.metadata()?.len();
            if size > limit {
                eprintln!(
                    "Info: Skipping large file: {} ({} > {})", 
                    relative_path_str, 
                    ByteSize(size), 
                    ByteSize(limit)
                );
                continue;
            }
        }

        // Check if binary
        let content = fs::read(path).context("Failed to read file")?;
        if !cli.include_binaries && content_inspector::inspect(&content) == ContentType::BINARY {
            eprintln!("Info: Skipping binary file: {}", relative_path_str);
            continue;
        }

        files.push(PathBuf::from(path));
    }

    // Sort files for consistent output
    files.sort();

    // Create output
    let mut writer = file_utils::get_output_writer(&cli.output)?;

    // Write preamble
    writer.write_all(preamble.as_bytes())?;
    writer.write_all(b"\n\n")?;

    // Write directory structure
    writer.write_all(b"## Directory Structure\n\n")?;
    writer.write_all(tree::generate_tree_structure(&files, &cli.root_path).as_bytes())?;
    writer.write_all(b"\n")?;

    // Write file contents
    writer.write_all(b"## File Contents\n\n")?;
    for path in &files {
        let relative_path = diff_paths(path, &cli.root_path)
            .context("Failed to calculate relative path")?;
        
        writer.write_all(format!("### {}\n\n", relative_path.display()).as_bytes())?;
        
        let content = fs::read(path).context("Failed to read file")?;
        if content_inspector::inspect(&content) == ContentType::BINARY {
            writer.write_all(b"[Binary File: Content not shown]\n\n")?;
            continue;
        }

        let lang = language::infer_language(path).unwrap_or("plaintext");
        writer.write_all(format!("```{}\n", lang).as_bytes())?;
        
        if let Ok(content) = String::from_utf8(content) {
            writer.write_all(content.as_bytes())?;
            if !content.ends_with('\n') {
                writer.write_all(b"\n")?;
            }
        } else {
            writer.write_all(b"[Error: File contains invalid UTF-8]\n")?;
        }
        
        writer.write_all(b"```\n\n")?;
    }

    // Write postamble
    writer.write_all(postamble.as_bytes())?;
    writer.write_all(b"\n")?;

    if cli.output != "-" {
        println!("Successfully generated prompt file: {}", cli.output);
    }

    Ok(())
}
